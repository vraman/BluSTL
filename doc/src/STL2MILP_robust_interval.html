<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of STL2MILP_robust_interval</title>
  <meta name="keywords" content="STL2MILP_robust_interval">
  <meta name="description" content="STL2MILP_robust_interval  constructs MILP constraints in YALMIP that compute">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">src</a> &gt; STL2MILP_robust_interval.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>STL2MILP_robust_interval
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>STL2MILP_robust_interval  constructs MILP constraints in YALMIP that compute</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> STL2MILP_robust_interval  constructs MILP constraints in YALMIP that compute
                           the robust interval of satisfaction, i.e. the 
                           lower and upper bounds on the robustness of 
                           satisfaction for specification phi


 Input: 
       phi:    an STLformula
       k:      the length of the trajectory
       ts:     the interval (in seconds) used for discretizing time
       var:    a dictionary mapping strings to variables
       M:       a large positive constant used for big-M constraints  

 Output: 
       F:  YALMIP constraints
       P:  a struct containing YALMIP decision variables representing 
           upper (Plow) and lower (Pup) bounds on quantitative satisfaction 
           of phi over each time step from 1 to k 

 :copyright: TBD
 :license: TBD</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>	STL2MILP_robust_interval  constructs MILP constraints in YALMIP that compute</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>	STL2MILP_robust_interval  constructs MILP constraints in YALMIP that compute</li><li><a href="STLC_get_controller.html" class="code" title="function controller = STLC_get_controller(Sys,enc)">STLC_get_controller</a>	STLC_get_controller constructs the controller object for an STLC_lti instance</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [F,z1,z2] = pred(st,k,var,M)</a></li><li><a href="#_sub2" class="code">function [F,Plow,Pup] = and(p_list1,p_list2,M)</a></li><li><a href="#_sub3" class="code">function [F,Plow,Pup] = or(p_list_low,p_list_up,M)</a></li><li><a href="#_sub4" class="code">function [F,Plow,Pup] = not(p_list1,p_list2)</a></li><li><a href="#_sub5" class="code">function [F,P_alwlow,P_alwup] = always(Plow,Pup,a,b, k,M)</a></li><li><a href="#_sub6" class="code">function [F,P_evlow,P_evup] = eventually(Plow,Pup,a,b, k,M)</a></li><li><a href="#_sub7" class="code">function [F,P_until1,P_until2] = until(PPlow,PPup,Pq1,Pq2,a,b,k,M)</a></li><li><a href="#_sub8" class="code">function [F,Plow,Pup] = min_r(p_list1,p_list2,M)</a></li><li><a href="#_sub9" class="code">function [F,Plow,Pup] = max_r(p_list1,p_list2,M)</a></li><li><a href="#_sub10" class="code">function [F,Plow,Pup] = until_mins(i,j,PPlow,PPup,Pq1,Pq2,M)</a></li><li><a href="#_sub11" class="code">function [ia, ib, over] = getIndices(i,a,b,k)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)</a>
0002 <span class="comment">% STL2MILP_robust_interval  constructs MILP constraints in YALMIP that compute</span>
0003 <span class="comment">%                           the robust interval of satisfaction, i.e. the</span>
0004 <span class="comment">%                           lower and upper bounds on the robustness of</span>
0005 <span class="comment">%                           satisfaction for specification phi</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Input:</span>
0009 <span class="comment">%       phi:    an STLformula</span>
0010 <span class="comment">%       k:      the length of the trajectory</span>
0011 <span class="comment">%       ts:     the interval (in seconds) used for discretizing time</span>
0012 <span class="comment">%       var:    a dictionary mapping strings to variables</span>
0013 <span class="comment">%       M:       a large positive constant used for big-M constraints</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% Output:</span>
0016 <span class="comment">%       F:  YALMIP constraints</span>
0017 <span class="comment">%       P:  a struct containing YALMIP decision variables representing</span>
0018 <span class="comment">%           upper (Plow) and lower (Pup) bounds on quantitative satisfaction</span>
0019 <span class="comment">%           of phi over each time step from 1 to k</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% :copyright: TBD</span>
0022 <span class="comment">% :license: TBD</span>
0023 
0024 <span class="comment">% NOT IN WORKING CONDITION</span>
0025 
0026     <span class="keyword">if</span> (nargin==4);
0027         M = 1000;
0028     <span class="keyword">end</span>;
0029         
0030     F = [];
0031     Plow = [];
0032     Pup = [];
0033     
0034     <span class="keyword">if</span> ischar(phi.interval)
0035         interval = [str2num(phi.interval)];
0036     <span class="keyword">else</span>
0037         interval = phi.interval;
0038     <span class="keyword">end</span>
0039     
0040     a = interval(1);
0041     b = interval(2);
0042         
0043     a = max([0 floor(a/ts)-1]); 
0044     b = ceil(b/ts)-1; 
0045     
0046     <span class="keyword">switch</span> (phi.type)
0047         
0048         <span class="keyword">case</span> <span class="string">'predicate'</span>
0049             [F,Plow,Pup] = <a href="#_sub1" class="code" title="subfunction [F,z1,z2] = pred(st,k,var,M)">pred</a>(phi.st,k,var,M);
0050                      
0051         <span class="keyword">case</span> <span class="string">'not'</span>
0052             [Frest,Prest_low,Prest_up] = <a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>(phi.phi,k,ts, var,M);
0053             [Fnot, Pnot_low,Pnot_up] = <a href="#_sub4" class="code" title="subfunction [F,Plow,Pup] = not(p_list1,p_list2)">not</a>(Prest_low,Prest_up);
0054             F = [F, Fnot, Frest];
0055             Plow = Pnot_low;
0056             Pup = Pnot_up;
0057 
0058         <span class="keyword">case</span> <span class="string">'or'</span>
0059             [Fdis1,Pdis1_low,Pdis1_up] = <a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>(phi.phi1,k,ts, var,M);
0060             [Fdis2,Pdis2_low,Pdis2_up] = <a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>(phi.phi2,k,ts, var,M);
0061             [For, Por_low,Por_up] = <a href="#_sub3" class="code" title="subfunction [F,Plow,Pup] = or(p_list_low,p_list_up,M)">or</a>([Pdis1_low;Pdis2_low],[Pdis1_up;Pdis2_up],M);
0062             F = [F, For, Fdis1, Fdis2];
0063             Plow = Por_low;
0064             Pup = Por_up;
0065 
0066         <span class="keyword">case</span> <span class="string">'and'</span>
0067             [Fcon1,Pcon11,Pcon12] = <a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>(phi.phi1,k,ts, var,M);
0068             [Fcon2,Pcon21,Pcon22] = <a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>(phi.phi2,k,ts, var,M);
0069             [Fand,Pand1,Pand2] = <a href="#_sub2" class="code" title="subfunction [F,Plow,Pup] = and(p_list1,p_list2,M)">and</a>([Pcon11;Pcon21],[Pcon12;Pcon22],M);
0070             F = [F, Fand, Fcon1, Fcon2];
0071             Plow = Pand1;
0072             Pup = Pand2;
0073 
0074         <span class="keyword">case</span> <span class="string">'=&gt;'</span>
0075             [Fant,Pant1,Pant2] = <a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>(phi.phi1,k, ts,var,M);
0076             [Fcons,Pcons1,Pcons2] = <a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>(phi.phi2,k,ts, var,M);
0077             [Fnotant,Pnotant1,Pnotant2] = <a href="#_sub4" class="code" title="subfunction [F,Plow,Pup] = not(p_list1,p_list2)">not</a>(Pant1,Pant2);
0078             [Fimp,PimPlow,PimPup] = <a href="#_sub3" class="code" title="subfunction [F,Plow,Pup] = or(p_list_low,p_list_up,M)">or</a>([Pnotant1;Pcons1],[Pnotant2;Pcons2],M);
0079             F = [F, Fant, Fnotant, Fcons, Fimp];
0080             Plow = PimPlow;
0081             Pup = PimPup;
0082             
0083         <span class="keyword">case</span> <span class="string">'always'</span>
0084             [Frest,Prest1,Prest2] = <a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>(phi.phi,k, ts, var,M);
0085             [Falw,Palw1,Palw2] = <a href="#_sub5" class="code" title="subfunction [F,P_alwlow,P_alwup] = always(Plow,Pup,a,b, k,M)">always</a>(Prest1,Prest2,a,b,k,M);
0086             F = [F, Falw];
0087             F = [F, Frest];
0088             Plow = Palw1;
0089             Pup = Palw2;
0090 
0091         <span class="keyword">case</span> <span class="string">'eventually'</span>
0092             [Frest,Prest1,Prest2] = <a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>(phi.phi,k, ts, var,M);
0093             [Fev,Pev1,Pev2] = <a href="#_sub6" class="code" title="subfunction [F,P_evlow,P_evup] = eventually(Plow,Pup,a,b, k,M)">eventually</a>(Prest1,Prest2,a,b,k,M);
0094             F = [F, Fev];
0095             F = [F, Frest];
0096             Plow = Pev1;
0097             Pup = Pev2;
0098           
0099         <span class="keyword">case</span> <span class="string">'until'</span>
0100             [Fp,PPlow,PPup] = <a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>(phi.phi1,k, ts, var,M);
0101             [Fq,Pq1,Pq2] = <a href="STL2MILP_robust_interval.html" class="code" title="function [F,Plow,Pup] = STL2MILP_robust_interval(phi,k,ts,var,M)">STL2MILP_robust_interval</a>(phi.phi2,k, ts, var,M);
0102             [Funtil,Puntil1,Puntil2] = <a href="#_sub7" class="code" title="subfunction [F,P_until1,P_until2] = until(PPlow,PPup,Pq1,Pq2,a,b,k,M)">until</a>(PPlow,PPup,Pq1,Pq2,a,b,k,M);
0103             F = [F,Funtil,Fp,Fq];
0104             Plow = Puntil1;
0105             Pup = Puntil2;
0106     <span class="keyword">end</span>   
0107 <span class="keyword">end</span>
0108 
0109 <a name="_sub1" href="#_subfunctions" class="code">function [F,z1,z2] = pred(st,k,var,M)</a>
0110     <span class="comment">% Enforce constraints based on predicates</span>
0111     <span class="comment">%</span>
0112     <span class="comment">% var is the variable dictionary</span>
0113         
0114     fnames = fieldnames(var);
0115     
0116     <span class="keyword">for</span> ifield= 1:numel(fnames)
0117         eval([ fnames{ifield} <span class="string">'= var.'</span> fnames{ifield} <span class="string">';'</span>]); 
0118     <span class="keyword">end</span>          
0119         
0120     
0121     st = regexprep(st,<span class="string">'\[t\]'</span>,<span class="string">'\(t\)'</span>); <span class="comment">% Breach compatibility ?</span>
0122     <span class="keyword">if</span> findstr(<span class="string">'&lt;'</span>, st)
0123         st = regexprep(st,<span class="string">'&lt;'</span>,<span class="string">'&lt;= '</span>);
0124         st = regexprep(st,<span class="string">'&lt;= '</span>,<span class="string">' +'</span>);
0125         st = [<span class="string">'-'</span>,st];           
0126     <span class="keyword">end</span>
0127     <span class="keyword">if</span> findstr(<span class="string">'&gt;'</span>, st)
0128         st = regexprep(st,<span class="string">'&gt;'</span>,<span class="string">'&gt;= '</span>);
0129         st = regexprep(st,<span class="string">'&gt;= '</span>,<span class="string">'-'</span>);
0130     <span class="keyword">end</span>
0131          
0132     F = [];
0133     zAll = [];
0134     
0135     <span class="keyword">for</span> l=1:k
0136         t_st = st;
0137         t_st = regexprep(t_st,<span class="string">'t\)'</span>,[num2str(l) <span class="string">'\)'</span>]);
0138         <span class="keyword">try</span> 
0139             z = eval(t_st);
0140         <span class="keyword">end</span>
0141         zAll = [zAll, z];
0142     <span class="keyword">end</span>
0143     
0144     <span class="comment">% take the and over all dimension for multi-dimensional signals</span>
0145     <span class="comment">% this is needed for example in 'ev_[3,5] (Y(1:2,t) &gt; [5;2])'</span>
0146     z = sdpvar(1,k);
0147     <span class="keyword">for</span> i=1:min(k,size(zAll,2))
0148        [Fnew, z(:,i)] = <a href="#_sub2" class="code" title="subfunction [F,Plow,Pup] = and(p_list1,p_list2,M)">and</a>(zAll(:,i),zAll(:,i),M);
0149        F = [F, Fnew];
0150     <span class="keyword">end</span>
0151     
0152     z1 = z;
0153     z2 = z;
0154   
0155 <span class="keyword">end</span>
0156 
0157 <span class="comment">% BOOLEAN OPERATIONS</span>
0158 
0159 <a name="_sub2" href="#_subfunctions" class="code">function [F,Plow,Pup] = and(p_list1,p_list2,M)</a>
0160     [F,Plow,Pup] = <a href="#_sub8" class="code" title="subfunction [F,Plow,Pup] = min_r(p_list1,p_list2,M)">min_r</a>(p_list1,p_list2,M);
0161 <span class="keyword">end</span>
0162 
0163 
0164 <a name="_sub3" href="#_subfunctions" class="code">function [F,Plow,Pup] = or(p_list_low,p_list_up,M)</a>
0165      [F,Plow,Pup] = <a href="#_sub9" class="code" title="subfunction [F,Plow,Pup] = max_r(p_list1,p_list2,M)">max_r</a>(p_list_low,p_list_up,M);
0166 <span class="keyword">end</span>
0167 
0168 
0169 <a name="_sub4" href="#_subfunctions" class="code">function [F,Plow,Pup] = not(p_list1,p_list2)</a>
0170     k = size(p_list1,2);
0171     m = size(p_list1,1);
0172 <span class="comment">%    assert( m == 1 )</span>
0173     Plow = sdpvar(m,k);
0174     Pup = sdpvar(m,k);
0175     F = [Plow == -p_list2, Pup == -p_list1];
0176 <span class="keyword">end</span>
0177 
0178 
0179 
0180 <span class="comment">% TEMPORAL OPERATIONS</span>
0181 
0182 <a name="_sub5" href="#_subfunctions" class="code">function [F,P_alwlow,P_alwup] = always(Plow,Pup,a,b, k,M)</a>
0183     F = [];
0184     P_alwlow = sdpvar(1,k);
0185     P_alwup = sdpvar(1,k);
0186     
0187     <span class="keyword">for</span> i = 1:k
0188         [ia, ib, over] = <a href="#_sub11" class="code" title="subfunction [ia, ib, over] = getIndices(i,a,b,k)">getIndices</a>(i,a,b,k);
0189         [F0,P0low,P0up] = <a href="#_sub2" class="code" title="subfunction [F,Plow,Pup] = and(p_list1,p_list2,M)">and</a>(Plow(ia:ib)',Pup(ia:ib)',M);
0190         <span class="keyword">if</span> over
0191             F0 = [F0, P_alwlow(i) == -M*.9];
0192         <span class="keyword">else</span>
0193             F0 = [F0, P_alwlow(i)==P0low];
0194         <span class="keyword">end</span>
0195         <span class="keyword">if</span> over == 2
0196             F0 = [F0, P_evlup(i) == M*.9];
0197         <span class="keyword">else</span>
0198             F = [F;F0,P_alwup(i)==P0up];
0199         <span class="keyword">end</span>
0200         
0201     <span class="keyword">end</span>
0202     
0203 <span class="keyword">end</span>
0204 
0205 
0206 <a name="_sub6" href="#_subfunctions" class="code">function [F,P_evlow,P_evup] = eventually(Plow,Pup,a,b, k,M)</a>
0207     F = [];
0208     P_evlow = sdpvar(1,k);
0209     P_evup = sdpvar(1,k);
0210     
0211     <span class="keyword">for</span> i = 1:k
0212         [ia, ib, over] = <a href="#_sub11" class="code" title="subfunction [ia, ib, over] = getIndices(i,a,b,k)">getIndices</a>(i,a,b,k);
0213         [F0,P0low,P0up] = <a href="#_sub3" class="code" title="subfunction [F,Plow,Pup] = or(p_list_low,p_list_up,M)">or</a>(Plow(ia:ib)',Pup(ia:ib)',M);
0214         <span class="keyword">if</span> over &gt;=1
0215             F0 = [F0, P_evup(i) == M*.9];
0216         <span class="keyword">else</span>
0217             F0 = [F0, P_evup(i)==P0up];
0218         <span class="keyword">end</span>
0219         <span class="keyword">if</span> over == 2
0220             F0 = [F0, P_evlow(i) == -M*.9];
0221         <span class="keyword">else</span>
0222             F = [F;F0,P_evlow(i)==P0low];
0223         <span class="keyword">end</span>
0224     <span class="keyword">end</span>
0225     
0226 <span class="keyword">end</span>
0227 
0228 
0229 <a name="_sub7" href="#_subfunctions" class="code">function [F,P_until1,P_until2] = until(PPlow,PPup,Pq1,Pq2,a,b,k,M)</a>
0230     
0231     F = [];
0232     P_until1 = sdpvar(1,k);
0233     P_until2 = sdpvar(1,k);
0234     
0235     <span class="keyword">for</span> i = 1:k
0236         [ia, ib] = <a href="#_sub11" class="code" title="subfunction [ia, ib, over] = getIndices(i,a,b,k)">getIndices</a>(i,a,b,k);
0237         F0 = []; 
0238         P0low = [];
0239         P0up = [];
0240         <span class="keyword">for</span> j = ia:ib
0241             [F1,Plow1,Plow2] = <a href="#_sub10" class="code" title="subfunction [F,Plow,Pup] = until_mins(i,j,PPlow,PPup,Pq1,Pq2,M)">until_mins</a>(i,j,PPlow,PPup,Pq1,Pq2,M);
0242             F0 = [F0, F1];
0243             P0low = [P0low,Plow1];
0244             P0up = [P0up,Plow2];
0245         <span class="keyword">end</span>
0246         [F4,P41,P42] = <a href="#_sub9" class="code" title="subfunction [F,Plow,Pup] = max_r(p_list1,p_list2,M)">max_r</a>(P0low,P0up);
0247         F = [F;F0,F4,P_until1(i)==P41,P_until2(i)==P42];
0248     <span class="keyword">end</span>
0249     
0250 <span class="keyword">end</span>
0251 
0252 
0253 <span class="comment">% UTILITY FUNCTIONS</span>
0254 
0255 <a name="_sub8" href="#_subfunctions" class="code">function [F,Plow,Pup] = min_r(p_list1,p_list2,M)</a>
0256     
0257     k = size(p_list1,2);
0258     m = size(p_list1,1);
0259     
0260     Plow = sdpvar(1,k);
0261     z1 = binvar(m,k);
0262     
0263     Pup = sdpvar(1,k);
0264     z2 = binvar(m,k);
0265      
0266     F = [sum(z1,1) == ones(1,k),sum(z2,1) == ones(1,k)];
0267     <span class="keyword">for</span> t=1:k
0268         <span class="keyword">for</span> i=1:m
0269             F = [F, Plow(t) &lt;= p_list1(i,t)];     
0270             F = [F, p_list1(i,t) - (1-z1(i,t))*M &lt;= Plow(t) &lt;= p_list1(i,t) + (1-z1(i,t))*M];
0271             F = [F, Plow(t) &lt;= p_list1(i,t)];     
0272             F = [F, p_list1(i,t) - (1-z1(i,t))*M &lt;= Plow(t) &lt;= p_list1(i,t) + (1-z1(i,t))*M];
0273         
0274             F = [F, Pup(t) &lt;= p_list2(i,t)];     
0275             F = [F, p_list2(i,t) - (1-z2(i,t))*M &lt;= Pup(t) &lt;= p_list2(i,t) + (1-z2(i,t))*M];
0276             F = [F, Pup(t) &lt;= p_list2(i,t)];     
0277             F = [F, p_list2(i,t) - (1-z2(i,t))*M &lt;= Pup(t) &lt;= p_list2(i,t) + (1-z2(i,t))*M];
0278         
0279         <span class="keyword">end</span>
0280     <span class="keyword">end</span>
0281 <span class="keyword">end</span>
0282 
0283 <a name="_sub9" href="#_subfunctions" class="code">function [F,Plow,Pup] = max_r(p_list1,p_list2,M)</a>
0284 
0285     k = size(p_list1,2);
0286     m = size(p_list1,1);
0287     
0288     Plow = sdpvar(1,k);
0289     z1 = binvar(m,k);
0290     
0291     Pup = sdpvar(1,k);
0292     z2 = binvar(m,k);
0293     
0294     F = [sum(z1,1) == ones(1,k),sum(z2,1) == ones(1,k)];
0295     <span class="keyword">for</span> t=1:k
0296         <span class="keyword">for</span> i=1:m
0297             F = [F, Plow(t) &gt;= p_list1(i,t)];     
0298             F = [F, p_list1(i,t) - (1-z1(i,t))*M &lt;= Plow(t) &lt;= p_list1(i,t) + (1-z1(i,t))*M];
0299             
0300             F = [F, Pup(t) &gt;= p_list2(i,t)];     
0301             F = [F, p_list2(i,t) - (1-z2(i,t))*M &lt;= Pup(t) &lt;= p_list2(i,t) + (1-z2(i,t))*M];        
0302         <span class="keyword">end</span>
0303     <span class="keyword">end</span>
0304 <span class="keyword">end</span>
0305 
0306 <a name="_sub10" href="#_subfunctions" class="code">function [F,Plow,Pup] = until_mins(i,j,PPlow,PPup,Pq1,Pq2,M)</a>
0307     [F0,P0low,P0up] = <a href="#_sub8" class="code" title="subfunction [F,Plow,Pup] = min_r(p_list1,p_list2,M)">min_r</a>(PPlow(i:j)',PPup(i:j)',M);
0308     [F1,Plow,Pup] = <a href="#_sub8" class="code" title="subfunction [F,Plow,Pup] = min_r(p_list1,p_list2,M)">min_r</a>([Pq1(j),P0low],[Pq2(j),P0up],M);
0309     F = [F0,F1];
0310 <span class="keyword">end</span>
0311 
0312 <a name="_sub11" href="#_subfunctions" class="code">function [ia, ib, over] = getIndices(i,a,b,k)</a>
0313     ia = min(k,i+a);
0314     ib = min(k,i+b);
0315     <span class="keyword">if</span> k &lt; i + b
0316         <span class="keyword">if</span> k &lt; i + a
0317             over = 2;
0318         <span class="keyword">else</span>
0319             over = 1;
0320         <span class="keyword">end</span>
0321     <span class="keyword">else</span>
0322         over = 0;
0323     <span class="keyword">end</span>
0324 <span class="keyword">end</span>
0325 
0326 
0327</pre></div>
<hr><address>Generated on Thu 09-Apr-2015 23:08:26 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>